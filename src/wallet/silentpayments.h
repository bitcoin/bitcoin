#ifndef BITCOIN_WALLET_SILENTPAYMENTS_H
#define BITCOIN_WALLET_SILENTPAYMENTS_H

#include <addresstype.h>
#include <coins.h>
#include <key_io.h>
#include <pubkey.h>
#include <undo.h>
#include <util/hasher.h>
#include <util/result.h>
#include <wallet/scriptpubkeyman.h>
#include <wallet/types.h>
#include <wallet/wallet.h>

#include <unordered_map>

namespace wallet {
CPubKey SumInputPubKeys(const std::vector<CPubKey>& input_pubkeys); // For the unit tests
uint256 GenerateSilentPaymentChangeTweak(const CKey& scan_key);
V0SilentPaymentDestination GenerateSilentPaymentLabeledAddress(const V0SilentPaymentDestination& receiver, const uint256& label);
CPubKey ComputeECDHSharedSecret(const CKey& scan_key, const CPubKey& sender_public_key, const uint256& outpoints_hash);
uint256 ComputeTweak(const CPubKey& ecdh_pubkey, const uint32_t output_index);
std::vector<uint256> GetTxOutputTweaks(const CPubKey& spend_pubkey, const CPubKey& ecdh_pubkey, std::vector<XOnlyPubKey> output_pub_keys, const std::map<CPubKey, uint256>& labels);
std::optional<std::pair<uint256, CPubKey>> GetSilentPaymentsTweakDataFromTxInputs(const std::vector<CTxIn>& vin, const std::map<COutPoint, Coin>& coins);

CPubKey CreateOutput(const CKey& ecdh_scalar, const CPubKey& scan_pubkey, const CPubKey& spend_pubkey, const uint32_t output_index);
uint256 HashOutpoints(const std::vector<COutPoint>& tx_outpoints);
std::map<size_t, WitnessV1Taproot> GenerateSilentPaymentTaprootDestinations(const CKey& ecdh_scalar, const std::map<size_t, V0SilentPaymentDestination>& sp_dests);
CKey PrepareScalarECDHInput(const std::vector<std::pair<CKey, bool>>& sender_secret_keys, const std::vector<COutPoint>& tx_outpoints);

class SilentPaymentsSPKM : public ScriptPubKeyMan
{
private:
    //! Destination containing scan and spend pubkeys
    V0SilentPaymentDestination m_address GUARDED_BY(cs_sp_man);
    //! Change destination (not stored, generated deterministically)
    V0SilentPaymentDestination m_change_address GUARDED_BY(cs_sp_man);

    //! The scan private key itself. Must not be encrypted.
    CKey m_scan_key GUARDED_BY(cs_sp_man);

    //! The unencrypted spend private key, if wallet is not encrypted
    CKey m_spend_key GUARDED_BY(cs_sp_man);
    //! The encrypted spend private key, if wallet is encrypted
    std::vector<unsigned char> m_spend_crypted_key GUARDED_BY(cs_sp_man);

    //! Map of output script to final silent payments tweak for that script, including the label
    //! The tweak is the sha256(ecdh_shared_secret || output_counter) + label
    std::unordered_map<CScript, uint256, SaltedSipHasher> m_spk_tweaks GUARDED_BY(cs_sp_man);

    //! Map of label index to the corresponding curve point as a Pubkey
    std::map<CPubKey, uint256> m_sp_labels GUARDED_BY(cs_sp_man);

    //! Timestamp for this spkm's creation
    int64_t m_creation_time;

    //! Number of labels that have been requested (highest label index + 1)
    int64_t m_labels_used;

    //! 256-bit ID
    uint256 m_id;

    //! Setup the labels map and the change label and its output
    void SetupLabels(int64_t labels_size) EXCLUSIVE_LOCKS_REQUIRED(cs_sp_man);

    //! Helper for getting SigningProviders with and without private keys
    std::unique_ptr<FlatSigningProvider> GetSigningProvider(const CScript& script, bool include_private) const EXCLUSIVE_LOCKS_REQUIRED(cs_sp_man);

public:
    //! Construct a SilentPaymentsSPKM from stored data
    SilentPaymentsSPKM(WalletStorage& storage, const uint256& id, const V0SilentPaymentDestination& address, const CKey& scan_key, const CKey& spend_key, const std::vector<unsigned char>& spend_ckey, const std::vector<uint256>& tweaks, int64_t labels_size, int64_t creation_time, int64_t labels_used);
    //! Construct a new autogenerated SilentPaymentsSPKM
    SilentPaymentsSPKM(WalletStorage& storage, int64_t labels_size, const CExtKey& master_key);

    mutable RecursiveMutex cs_sp_man;

    util::Result<CTxDestination> GetNewDestination(const OutputType type) override;
    isminetype IsMine(const CScript& script) const override;

    bool CheckDecryptionKey(const CKeyingMaterial& master_key, bool accept_no_keys = false) override;
    bool Encrypt(const CKeyingMaterial& master_key, WalletBatch* batch) override;

    util::Result<CTxDestination> GetReservedDestination(const OutputType type, bool internal, int64_t& index, CKeyPool& keypool) override;

    bool TopUp(unsigned int size = 0) override;

    // HD isn't really a concept that makes sense for silent payments, just return true unconditionally to avoid breaking other stuff
    bool IsHDEnabled() const override { return true; }
    bool CanGetAddresses(bool internal = false) const override { return true; }
    bool HavePrivateKeys() const override
    {
        // TODO: Watch-only silent payments are not yet implemented
        return true;
    }

    std::optional<int64_t> GetOldestKeyPoolTime() const override;
    unsigned int GetKeyPoolSize() const override;
    int64_t GetTimeFirstKey() const override;

    std::unique_ptr<CKeyMetadata> GetMetadata(const CTxDestination& dest) const override;
    std::unique_ptr<SigningProvider> GetSolvingProvider(const CScript& script) const override;

    bool CanProvide(const CScript& script, SignatureData& sigdata) override;
    bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, bilingual_str>& input_errors) const override;
    SigningResult SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const override;
    TransactionError FillPSBT(PartiallySignedTransaction& psbt, const PrecomputedTransactionData& txdata, int sighash_type = SIGHASH_DEFAULT, bool sign = true, bool bip32derivs = false, int* n_signed = nullptr, bool finalize = true) const override;

    uint256 GetID() const override;

    std::unordered_set<CScript, SaltedSipHasher> GetScriptPubKeys() const override;

    isminetype IsMineSilentPayments(const CTransaction& tx, const std::map<COutPoint, Coin>& coins);
};
} // namespace wallet
#endif // BITCOIN_WALLET_SILENTPAYMENTS_H
