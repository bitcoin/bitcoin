#ifndef SECP256K1_MODULE_BATCH_MAIN_H
#define SECP256K1_MODULE_BATCH_MAIN_H

#include "../../../include/secp256k1_batch.h"

/* Maximum number of scalar-point pairs on the batch
 * for which `secp256k1_batch_verify` remains efficient */
#define STRAUSS_MAX_TERMS_PER_BATCH 106

/* Ensures unique randomizers across different batch_add_* functions.
 *
 * Without this tag, two batch contexts could generate identical randomizers
 * if given the same input bytes, even when using different batch_add_*
 * functions (e.g., batch_add_tweak_check vs batch_add_schnorrsig).
 *
 * Including this tag in randomizer generation prevents such collisions by
 * differentiating between the different batch_add_* function types.
 */
enum batch_add_type {schnorrsig = 1, tweak_check = 2};

/** Opaque data structure for batch verification context.
 *
 *  Members:
 *       data: scratch space containing points (secp256k1_gej) and their
 *             corresponding scalars for use in multi-scalar multiplication
 *             algorithms (Strauss, Pippenger).
 *    scalars: pointer to scalars allocated in the scratch space.
 *     points: pointer to points allocated in the scratch space.
 *       sc_g: scalar corresponding to the generator point (G) in the
 *             multi-scalar multiplication equation.
 *     sha256: hash of all inputs (signatures/tweaks) in the batch except the first.
 *             Used to generate a random secp256k1_scalar for each term added by
 *             secp256k1_batch_add_*.
 *        len: number of scalar-point pairs currently in the batch.
 *   capacity: maximum number of scalar-point pairs the batch can hold.
 *     result: indicates whether all inputs (signatures or tweak checks) are valid.
 *             1 = valid, 0 = invalid. Initialized to 1 by secp256k1_batch_create.
 *
 *  This struct is typedef'd as secp256k1_batch in include/secp256k1_batch.h.
 */
struct secp256k1_batch_struct{
    secp256k1_scratch *data;
    secp256k1_scalar *scalars;
    secp256k1_gej *points;
    secp256k1_scalar sc_g;
    secp256k1_sha256 sha256;
    size_t len;
    size_t capacity;
    int result;
};

static size_t secp256k1_batch_scratch_size(int max_terms) {
    size_t ret = secp256k1_strauss_scratch_size(max_terms) + STRAUSS_SCRATCH_OBJECTS*16;
    VERIFY_CHECK(ret != 0);

    return ret;
}

/** Clears the scalar and points allocated on the batch object's scratch space */
static void secp256k1_batch_scratch_clear(secp256k1_batch* batch) {
    secp256k1_scalar_set_int(&batch->sc_g, 0);
    /* setting the len = 0 will suffice (instead of clearing the memory)
     * since, there are no secrets stored on the scratch space */
    batch->len = 0;
}

/** Allocates space for `batch->capacity` number of scalars and points on batch
 *  object's scratch space */
static int secp256k1_batch_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_batch* batch) {
    size_t checkpoint = secp256k1_scratch_checkpoint(error_callback, batch->data);
    size_t count = batch->capacity;

    VERIFY_CHECK(count > 0);

    batch->scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(error_callback, batch->data, count*sizeof(secp256k1_scalar));
    batch->points = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, batch->data, count*sizeof(secp256k1_gej));

    /* If scalar or point allocation fails, restore scratch space to previous state */
    if (batch->scalars == NULL || batch->points == NULL) {
        secp256k1_scratch_apply_checkpoint(error_callback, batch->data, checkpoint);
        return 0;
    }

    return 1;
}

/* Initializes SHA256 with fixed midstate. This midstate was computed by applying
 * SHA256 to SHA256("BIP0340/batch")||SHA256("BIP0340/batch"). */
static void secp256k1_batch_sha256_tagged(secp256k1_sha256 *sha) {
    secp256k1_sha256_initialize(sha);
    sha->s[0] = 0x79e3e0d2ul;
    sha->s[1] = 0x12284f32ul;
    sha->s[2] = 0xd7d89e1cul;
    sha->s[3] = 0x6491ea9aul;
    sha->s[4] = 0xad823b2ful;
    sha->s[5] = 0xfacfe0b6ul;
    sha->s[6] = 0x342b78baul;
    sha->s[7] = 0x12ece87cul;

    sha->bytes = 64;
}

secp256k1_batch* secp256k1_batch_create(const secp256k1_context* ctx, size_t max_terms, const unsigned char *aux_rand16) {
    size_t batch_size;
    secp256k1_batch* batch;
    size_t batch_scratch_size;
    unsigned char zeros[16] = {0};
    /* max number of scalar-point pairs on scratch up to which Strauss multi multiplication is efficient */
    if (max_terms > STRAUSS_MAX_TERMS_PER_BATCH) {
        max_terms = STRAUSS_MAX_TERMS_PER_BATCH;
    }

    VERIFY_CHECK(ctx != NULL);
    ARG_CHECK(max_terms != 0);

    batch_size = sizeof(secp256k1_batch);
    batch = (secp256k1_batch *)checked_malloc(&ctx->error_callback, batch_size);
    batch_scratch_size = secp256k1_batch_scratch_size(max_terms);
    if (batch != NULL) {
        /* create scratch space inside batch object, if that fails return NULL*/
        batch->data = secp256k1_scratch_create(&ctx->error_callback, batch_scratch_size);
        if (batch->data == NULL) {
            return NULL;
        }
        /* allocate memory for `max_terms` number of scalars and points on scratch space */
        batch->capacity = max_terms;
        if (!secp256k1_batch_scratch_alloc(&ctx->error_callback, batch)) {
            /* if scratch memory allocation fails, free all the previous the allocated memory
            and return NULL */
            secp256k1_scratch_destroy(&ctx->error_callback, batch->data);
            free(batch);
            return NULL;
        }

        /* set remaining data members */
        secp256k1_scalar_set_int(&batch->sc_g, 0);
        secp256k1_batch_sha256_tagged(&batch->sha256);
        if (aux_rand16 != NULL) {
            secp256k1_sha256_write(&batch->sha256, aux_rand16, 16);
        } else {
            /* use 16 bytes of 0x0000...000, if no fresh randomness provided */
            secp256k1_sha256_write(&batch->sha256, zeros, 16);
        }
        batch->len = 0;
        batch->result = 1;
    }

    return batch;
}

void secp256k1_batch_reset(const secp256k1_context *ctx, secp256k1_batch *batch) {
    VERIFY_CHECK(ctx != NULL);
    ARG_CHECK_VOID(batch != NULL);

    secp256k1_batch_scratch_clear(batch);
    secp256k1_batch_sha256_tagged(&batch->sha256);
    batch->result = 1;
}

void secp256k1_batch_destroy(const secp256k1_context *ctx, secp256k1_batch *batch) {
    VERIFY_CHECK(ctx != NULL);
    ARG_CHECK_VOID(batch != NULL);

    if (batch != NULL) {
        if(batch->data != NULL) {
            /* can't destroy a scratch space with non-zero size */
            secp256k1_scratch_apply_checkpoint(&ctx->error_callback, batch->data, 0);
            secp256k1_scratch_destroy(&ctx->error_callback, batch->data);
        }
        free(batch);
    }
}

int secp256k1_batch_verify(const secp256k1_context *ctx, secp256k1_batch *batch) {
    secp256k1_gej resj;

    VERIFY_CHECK(ctx != NULL);
    ARG_CHECK(batch != NULL);
    ARG_CHECK(batch->len <= batch->capacity);

    if(batch->result == 0) {
        return 0;
    }

    if (batch->len > 0) {
        int strauss_ret = secp256k1_ecmult_strauss_batch_internal(&ctx->error_callback, batch->data, &resj, batch->scalars, batch->points, &batch->sc_g, batch->len);
        int mid_res = secp256k1_gej_is_infinity(&resj);

        /* `_strauss_batch_internal` should not fail due to insufficient memory.
         * `batch_create` will allocate memeory needed by `_strauss_batch_internal`. */
        VERIFY_CHECK(strauss_ret != 0);
        /* Silence âˆ’Wunused-variable when VERIFY is off */
        (void)strauss_ret;

        batch->result = batch->result && mid_res;
        secp256k1_batch_scratch_clear(batch);
    }

    return batch->result;
}

#endif /* SECP256K1_MODULE_BATCH_MAIN_H */
