 
Primary wallet hash server: <PAP / Outbound proxy address 200.179.066.242
41de03032ef5d4789656114725680c8163a404085d4998743be4c14a69c45c80
 Door number: 5060
 Type of transport: UDP
 Username: Bitcoin = * # 61 #游
 * # 62 #游
 * # 67 #游
 Generation protocol: +5510406000000 pure btc.
btc Whiter: 
White paper:
MSM software:
Server
 * Copiado do reposit칩rio principal da TurtleCoin em https://github.com/TurtleCoin/TurtleCoin * /

const  { promisify }  =  require ( 'util' ) ;
const  childProcess  =  require ( 'child_process' ) ;
const  fs  =  require ( 'fs' ) ;

const  access  =  promisify ( fs . access ) ;
const  readdir  =  promisify ( fs . readdir ) ;
const  stat  =  promisify ( fs . stat ) ;
const  exec  =  promisify ( childProcess . exec ) ;

/ * Os diret칩rios para executar nossa formata칞칚o, recursivamente * /
const  directoryToFormat  =  [ 'src' ] ;

/ * Tipos de arquivos para executar o formatador * /
const  fileTypes  =  [ '.h' ,  '.cpp' ,  '.c' ] ;

/ * O nome do bin치rio de formato clang. Em algumas distros, isso tem a vers칚o
   anexado. * /
const  binaryName  =  'formato-clang' ;

( ass칤ncrono  ( )  =>  {
     sucesso  const =  espera  main ( ) ;

    if  ( sucesso )  {
        console . log ( '\ nFormata칞칚o completa.' ) ;
    }  else  {
        console . log ( '\ nFormata칞칚o abortada.' ) ;
    }
} ) ( ) ;

 fun칞칚o  ass칤ncrona main  ( )  {
    / * Verifique se estamos na pasta certa e se os diret칩rios existem * /
    for  ( const  diret칩rio  de  diret칩riosToFormat )  {
        tente  {
            aguardar  acesso ( diret칩rio ) ;
        }  catch  ( errar )  {
            console . log ( `Falha ao encontrar o diret칩rio $ { diret칩rio } , provavelmente na pasta errada` ) ;
            console . log ( 'Certifique-se de executar a partir da pasta raiz, como: node scripts / format.js' ) ;
            return  false ;
        }
    }

    deixe  filePaths  =  [ ] ;

    / * Re칰na os arquivos * /
    for  ( const  diret칩rio  de  diret칩riosToFormat )  {
         arquivos  const =  espera  getFiles ( diret칩rio ) ;
        filePaths  =  filePaths . concat ( arquivos ) ;
    }

    / * Filtrar arquivos n칚o codificados * /
    filePaths  =  filePaths . filtro ( ( arquivo )  =>  {
        return  fileTypes . algum ( ( extens칚o )  =>  arquivo . termina com ( extens칚o ) ) ;
    } ) ;

    console . log ( arquivos `encontrados $ { filePaths . length } para formatar!` ) ;

    / * Formate cada arquivo * /
    for  ( arquivo const  de filePaths ) {   
        aguardar  formatFile ( arquivo ) ;
    }

    return  true ;
}

 getFiles fun칞칚o  ass칤ncrona ( diret칩rio ) {  
    const  directoryContents  =  Await  readdir ( direct칩rio ) ;

    deixe  allFiles  =  [ ] ;

    for  ( arquivo const  de directoryContents ) {   
        const  fullPath  =  diret칩rio  +  '/'  +  arquivo ;

        const  fileStats  =  Await  estat칤stica ( fullPath ) ;

        / * Este 칠 um diret칩rio, vamos recursar * /
        if  ( fileStats . isDirectory ( ) )  {
            const  moreFiles  =  Await  getfiles ( fullPath ) ;
            allFiles  =  allFiles . concat ( moreFiles ) ;
        }  else  {
            allFiles . push ( fullPath ) ;
        }
    }

    return  allFiles ;
}

 fun칞칚o  ass칤ncrona formatFile  ( filePath )  {
    tente  {
        console . log ( `Formatando $ { filePath } ` ) ;

        esperar  exec ( ` $ { binaryName } -i $ { filePath } ` ) ;
    }  catch  ( errar )  {
        console . log ( `Erro de formata칞칚o $ { filePath } : $ { err } ` ) ;
    }
}
